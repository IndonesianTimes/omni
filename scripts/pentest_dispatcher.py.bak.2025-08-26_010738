#!/usr/bin/env python3
import argparse, json, subprocess, os, sys, csv

def run_cmd(cmd, cwd=None, allow_fail=False):
    print("[CMD]", " ".join(cmd))
    try:
        subprocess.run(cmd, cwd=cwd, check=True)
    except subprocess.CalledProcessError as e:
        print(f"[ERR] Command failed: {e}")
        if not allow_fail:
            sys.exit(1)

def export_csv_from_jsonl(jsonl_path, csv_path):
    rows = 0
    with open(csv_path, "w", newline="", encoding="utf-8") as g:
        w = csv.DictWriter(g, fieldnames=[
            "host","template_id","severity","klass","matched","timestamp","template_url","matcher_status","extracted"
        ])
        w.writeheader()
        with open(jsonl_path, "r", encoding="utf-8", errors="ignore") as f:
            for line in f:
                line=line.strip()
                if not line: 
                    continue
                try:
                    x = json.loads(line)
                except Exception:
                    continue
                host = x.get("host") or x.get("ip") or ""
                template_id = x.get("templateID","")
                severity = (x.get("info") or {}).get("severity") or x.get("severity") or ""
                tags = x.get("tags")
                tags_str = ",".join(tags) if isinstance(tags, list) else (str(tags) if tags else "")
                klass = "takeover" if "takeover" in tags_str else ("file-upload" if ("file-upload" in tags_str or "fileupload" in tags_str) else (x.get("type") or ""))
                matched = x.get("matched") or x.get("matcher_name") or ""
                timestamp = x.get("timestamp") or x.get("time") or ""
                template_url = (x.get("info") or {}).get("reference") or ""
                matcher_status = x.get("matcher_status","")
                extractor = x.get("extracted_results")
                extracted = ",".join(map(str, extractor)) if isinstance(extractor, list) else (extractor or "")
                w.writerow({
                    "host":host, "template_id":template_id, "severity":severity, "klass":klass,
                    "matched":matched, "timestamp":timestamp, "template_url":template_url if isinstance(template_url,str) else "",
                    "matcher_status":matcher_status, "extracted":extracted
                })
                rows += 1
    print(f"[OK] CSV -> {csv_path} ({rows} rows)")

def export_csv_from_txt(raw_dir, csv_path):
    """Fallback kalau belum ada JSONL: gabungkan 2 file .out.txt jadi CSV sederhana."""
    files = [
        ("takeover", os.path.join(raw_dir, "nuclei_takeover.out.txt")),
        ("file-upload", os.path.join(raw_dir, "nuclei_fileupload.out.txt")),
    ]
    rows = 0
    with open(csv_path, "w", newline="", encoding="utf-8") as g:
        w = csv.DictWriter(g, fieldnames=["klass","raw_line","source_file"])
        w.writeheader()
        for klass, path in files:
            if not os.path.exists(path):
                continue
            with open(path, "r", encoding="utf-8", errors="ignore") as f:
                for line in f:
                    line=line.rstrip("\n")
                    if not line: 
                        continue
                    w.writerow({"klass":klass, "raw_line":line, "source_file":os.path.basename(path)})
                    rows += 1
    print(f"[OK] CSV (fallback) -> {csv_path} ({rows} rows)")

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("-q","--queue", required=True, help="pentest_queue.jsonl")
    ap.add_argument("-o","--outdir", required=True, help="job output dir")
    ap.add_argument("--nuclei", required=True, help="path to nuclei binary")
    ap.add_argument("--templates", required=True, help="path to nuclei-templates")
    ap.add_argument("--rate", type=int, default=120)
    ap.add_argument("--concurrency", type=int, default=20)
    ap.add_argument("--timeout", type=int, default=15)
    args = ap.parse_args()

    outdir = args.outdir
    raw_dir = os.path.join(outdir, "pentest_raw")
    os.makedirs(raw_dir, exist_ok=True)

    nuclei_bin = args.nuclei
    templates_dir = args.templates

    # === NUCLEI RUNS (scope ketat: takeover + file-upload, high/critical) ===
    cmd_takeover = [
        nuclei_bin, "-templates", templates_dir, "-tags", "takeover",
        "-severity", "critical,high",
        "-rl", str(args.rate), "-c", str(args.concurrency),
        "-timeout", str(args.timeout), "-retries", "1",
        "-silent", "-no-color",
        "-l", f"{raw_dir}/targets_takeover.txt",
        "-o", f"{raw_dir}/nuclei_takeover.out.txt"
    ]
    run_cmd(cmd_takeover, allow_fail=True)  # allow_fail=True â†’ tetap lanjut walau 0/empty

    cmd_upload = [
        nuclei_bin, "-templates", templates_dir, "-tags", "file-upload",
        "-severity", "critical,high",
        "-rl", str(args.rate), "-c", str(args.concurrency),
        "-timeout", str(args.timeout), "-retries", "1",
        "-silent", "-no-color",
        "-l", f"{raw_dir}/targets_upload.txt",
        "-o", f"{raw_dir}/nuclei_fileupload.out.txt"
    ]
    run_cmd(cmd_upload, allow_fail=True)

    # === SUMMARY ===
    takeover_out = os.path.join(raw_dir, "nuclei_takeover.out.txt")
    upload_out   = os.path.join(raw_dir, "nuclei_fileupload.out.txt")
    takeover_lines = sum(1 for _ in open(takeover_out, "r", encoding="utf-8", errors="ignore")) if os.path.exists(takeover_out) else 0
    upload_lines   = sum(1 for _ in open(upload_out,   "r", encoding="utf-8", errors="ignore")) if os.path.exists(upload_out) else 0
    summary_path = os.path.join(outdir, "pentest_summary.txt")
    with open(summary_path, "w", encoding="utf-8") as sf:
        sf.write(f"[takeover] {takeover_lines} lines -> {takeover_out}\n")
        sf.write(f"[file-upload] {upload_lines} lines -> {upload_out}\n")
    print("[OK] summary ->", summary_path)

    # === CSV EXPORTER ===
    jsonl_path = os.path.join(outdir, "pentest_results.jsonl")
    csv_path   = os.path.join(outdir, "pentest_results.csv")
    if os.path.exists(jsonl_path) and os.path.getsize(jsonl_path) > 0:
        export_csv_from_jsonl(jsonl_path, csv_path)
    else:
        export_csv_from_txt(raw_dir, csv_path)

if __name__ == "__main__":
    main()
