#!/usr/bin/env python3
import argparse, json, subprocess, os, sys, csv

def run_cmd(cmd, cwd=None, allow_fail=False):
    print("[CMD]", " ".join(cmd))
    try:
        subprocess.run(cmd, cwd=cwd, check=True)
    except subprocess.CalledProcessError as e:
        print(f"[ERR] Command failed: {e}")
        if not allow_fail:
            sys.exit(1)

def export_csv_from_jsonl(jsonl_path, csv_path):
    rows = 0
    with open(csv_path, "w", newline="", encoding="utf-8") as g:
        w = csv.DictWriter(g, fieldnames=[
            "host","template_id","severity","klass","matched","timestamp","template_url","matcher_status","extracted"
        ])
        w.writeheader()
        if not os.path.exists(jsonl_path) or os.path.getsize(jsonl_path) == 0:
            return 0
        with open(jsonl_path, "r", encoding="utf-8", errors="ignore") as f:
            for line in f:
                s = line.strip()
                if not s:
                    continue
                try:
                    x = json.loads(s)
                except Exception:
                    continue
                # skip meta/status lines
                if x.get("kind") in ("nuclei-takeover","nuclei-file-upload","nuclei-run"):
                    continue
                host = x.get("host") or x.get("ip") or ""
                template_id = x.get("templateID","")
                matched = x.get("matched") or x.get("matcher_name") or ""
                if not (host or template_id or matched):
                    continue
                severity = (x.get("info") or {}).get("severity") or x.get("severity") or ""
                tags = x.get("tags")
                tags_str = ",".join(tags) if isinstance(tags, list) else (str(tags) if tags else "")
                if "takeover" in tags_str:
                    klass = "takeover"
                elif ("file-upload" in tags_str) or ("fileupload" in tags_str):
                    klass = "file-upload"
                elif "rce" in tags_str:
                    klass = "rce"
                elif "cve" in tags_str:
                    klass = "cve"
                else:
                    klass = (x.get("type") or "")
                timestamp = x.get("timestamp") or x.get("time") or ""
                template_url = (x.get("info") or {}).get("reference") or ""
                matcher_status = x.get("matcher_status","")
                extractor = x.get("extracted_results")
                extracted = ",".join(map(str, extractor)) if isinstance(extractor, list) else (extractor or "")
                w.writerow({
                    "host":host, "template_id":template_id, "severity":severity, "klass":klass,
                    "matched":matched, "timestamp":timestamp,
                    "template_url":template_url if isinstance(template_url,str) else "",
                    "matcher_status":matcher_status, "extracted":extracted
                })
                rows += 1
    return rows

def export_csv_from_txt(raw_dir, csv_path):
    files = []
    for name in os.listdir(raw_dir):
        if name.startswith("nuclei_") and name.endswith(".out.txt"):
            klass = name.replace("nuclei_","").replace(".out.txt","")
            if klass == "fileupload":  # normalisasi
                klass = "file-upload"
            files.append((klass, os.path.join(raw_dir, name)))
    files.sort()
    rows = 0
    with open(csv_path, "w", newline="", encoding="utf-8") as g:
        w = csv.DictWriter(g, fieldnames=["klass","raw_line","source_file"])
        w.writeheader()
        for klass, path in files:
            if not (os.path.exists(path) and os.path.getsize(path) > 0):
                continue
            with open(path, "r", encoding="utf-8", errors="ignore") as f:
                for line in f:
                    s = line.rstrip("\n")
                    if not s:
                        continue
                    w.writerow({"klass":klass, "raw_line":s, "source_file":os.path.basename(path)})
                    rows += 1
    return rows

def ensure_dir(p): os.makedirs(p, exist_ok=True)

def input_file_for(tag, raw_dir):
    """Pilih file target yang tepat dan pastikan minimal ada (touch)."""
    # canonical names
    if tag == "takeover":
        path = os.path.join(raw_dir, "targets_takeover.txt")
        if not os.path.exists(path): open(path,"a").close()
        return path
    if tag in ("file-upload","fileupload"):
        preferred = os.path.join(raw_dir, "targets_fileupload.txt")
        fallback  = os.path.join(raw_dir, "targets_upload.txt")
        # pastikan keduanya ada; kalau preferred tidak ada, bikin kosong
        if not os.path.exists(preferred): open(preferred,"a").close()
        if not os.path.exists(fallback):  open(fallback,"a").close()
        # gunakan preferred bila punya isi, kalau kosong pakai fallback
        try:
            if os.path.getsize(preferred) > 0: return preferred
        except Exception: pass
        return fallback
    # extra tags: gunakan daftar umum semua http(s) target
    common = os.path.join(raw_dir, "targets_upload.txt")
    if not os.path.exists(common): open(common,"a").close()
    return common

def tag_to_outfile(tag):
    if tag == "takeover": return "nuclei_takeover.out.txt"
    if tag in ("file-upload","fileupload"): return "nuclei_fileupload.out.txt"
    safe = tag.replace("/", "_").replace(":", "_").replace("-", "")
    return f"nuclei_{safe}.out.txt"

def run_tag(nuclei_bin, templates_dir, tag, raw_dir, rate, concurrency, timeout):
    in_file  = input_file_for(tag, raw_dir)
    out_file = os.path.join(raw_dir, tag_to_outfile(tag))
    cmd = [
        nuclei_bin, "-templates", templates_dir, "-tags", tag,
        "-severity", "critical,high",
        "-rl", str(rate), "-c", str(concurrency),
        "-timeout", str(timeout), "-retries", "1",
        "-silent", "-no-color",
        "-l", in_file,
        "-o", out_file
    ]
    run_cmd(cmd, allow_fail=True)
    return out_file

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("-q","--queue", required=True, help="pentest_queue.jsonl")
    ap.add_argument("-o","--outdir", required=True, help="job output dir")
    ap.add_argument("--nuclei", required=True, help="path to nuclei binary")
    ap.add_argument("--templates", required=True, help="path to nuclei-templates")
    ap.add_argument("--rate", type=int, default=120)
    ap.add_argument("--concurrency", type=int, default=20)
    ap.add_argument("--timeout", type=int, default=15)
    ap.add_argument("--extra-tags", default=os.environ.get("NUCLEI_EXTRA_TAGS",""), help="comma separated, e.g. rce,cve")
    args = ap.parse_args()

    outdir = args.outdir
    raw_dir = os.path.join(outdir, "pentest_raw")
    ensure_dir(raw_dir)

    nuclei_bin = args.nuclei
    templates_dir = args.templates

    # tags core + optional
    tags = ["takeover", "file-upload"]
    extra = [t.strip() for t in args.extra_tags.split(",") if t.strip()]
    for t in extra:
        if t not in tags:
            tags.append(t)

    produced = []
    for tag in tags:
        produced.append((tag, run_tag(nuclei_bin, templates_dir, tag, raw_dir, args.rate, args.concurrency, args.timeout)))

    # summary
    summary_path = os.path.join(outdir, "pentest_summary.txt")
    with open(summary_path, "w", encoding="utf-8") as sf:
        for tag, path in produced:
            lines = 0
            if os.path.exists(path):
                with open(path, "r", encoding="utf-8", errors="ignore") as f:
                    lines = sum(1 for _ in f if _.strip())
            sf.write(f"[{tag}] {lines} lines -> {path}\n")
    print("[OK] summary ->", summary_path)

    # CSV
    jsonl_path = os.path.join(outdir, "pentest_results.jsonl")
    csv_path   = os.path.join(outdir, "pentest_results.csv")
    written = 0
    if os.path.exists(jsonl_path) and os.path.getsize(jsonl_path) > 0:
        written = export_csv_from_jsonl(jsonl_path, csv_path)
    if written == 0:
        written = export_csv_from_txt(raw_dir, csv_path)
    print(f"[OK] CSV -> {csv_path} (rows={written})")

if __name__ == "__main__":
    main()
